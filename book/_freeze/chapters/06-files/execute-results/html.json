{
  "hash": "5eb482dc756d6654881f4ded3c8c2025",
  "result": {
    "engine": "jupyter",
    "markdown": "# 文件操作与外部数据 {#sec-files}\n\n::: {.callout-note}\n## 本章概要\n- **课时**：2课时（第6周）\n- **目标**：掌握文件读写操作，培养自动化脚本思维\n:::\n\n## 学习目标\n\n完成本章后，你将能够：\n\n1. 读写文本文件、CSV 文件\n2. 用 AI 处理文件路径问题\n3. 编写批量处理文件的脚本\n\n---\n\n## 文件操作基础\n\n### 文件操作流程\n\n```{mermaid}\nflowchart LR\n    A[\"打开文件\"] --> B[\"读取/写入\"]\n    B --> C[\"关闭文件\"]\n    \n    D[\"with open() as f:\"] --> E[\"自动管理\"]\n    E --> F[\"自动关闭\"]\n    \n    style D fill:#e8f5e9\n    style E fill:#e8f5e9\n    style F fill:#e8f5e9\n```\n\n### 读取文本文件\n\n::: {#f6e9e1e3 .cell execution_count=1}\n``` {.python .cell-code}\n# 方法 1：读取全部内容\nwith open(\"data.txt\", \"r\", encoding=\"utf-8\") as f:\n    content = f.read()\n    print(content)\n\n# 方法 2：按行读取\nwith open(\"data.txt\", \"r\", encoding=\"utf-8\") as f:\n    for line in f:\n        print(line.strip())  # strip() 去除换行符\n\n# 方法 3：读取为列表\nwith open(\"data.txt\", \"r\", encoding=\"utf-8\") as f:\n    lines = f.readlines()\n    print(f\"共 {len(lines)} 行\")\n```\n:::\n\n\n### 写入文本文件\n\n::: {#3b673f94 .cell execution_count=2}\n``` {.python .cell-code}\n# 写入（覆盖）\nwith open(\"output.txt\", \"w\", encoding=\"utf-8\") as f:\n    f.write(\"第一行\\n\")\n    f.write(\"第二行\\n\")\n\n# 追加写入\nwith open(\"output.txt\", \"a\", encoding=\"utf-8\") as f:\n    f.write(\"追加的内容\\n\")\n\n# 写入多行\nlines = [\"Line 1\", \"Line 2\", \"Line 3\"]\nwith open(\"output.txt\", \"w\", encoding=\"utf-8\") as f:\n    f.writelines(line + \"\\n\" for line in lines)\n```\n:::\n\n\n::: {.callout-important}\n## 始终使用 with 语句！\n`with` 语句会自动关闭文件，即使发生错误也能正确关闭，避免资源泄露。\n:::\n\n---\n\n## CSV 文件处理\n\n### CSV 文件格式\n\nCSV（Comma-Separated Values）是最常见的数据交换格式之一：\n\n```\n学号,姓名,成绩\n001,张三,85\n002,李四,92\n003,王五,78\n```\n\n### 读取 CSV 文件\n\n::: {#bdb68cde .cell execution_count=3}\n``` {.python .cell-code}\nimport csv\n\n# 方法 1：csv.reader（返回列表）\nwith open(\"grades.csv\", \"r\", encoding=\"utf-8\") as f:\n    reader = csv.reader(f)\n    header = next(reader)  # 跳过标题行\n    for row in reader:\n        print(f\"{row[1]}: {row[2]}分\")\n\n# 方法 2：csv.DictReader（返回字典，推荐！）\nwith open(\"grades.csv\", \"r\", encoding=\"utf-8\") as f:\n    reader = csv.DictReader(f)\n    for row in reader:\n        print(f\"{row['姓名']}: {row['成绩']}分\")\n```\n:::\n\n\n### 写入 CSV 文件\n\n::: {#b27f0af8 .cell execution_count=4}\n``` {.python .cell-code}\nimport csv\n\n# 准备数据\nstudents = [\n    {\"学号\": \"001\", \"姓名\": \"张三\", \"成绩\": 85},\n    {\"学号\": \"002\", \"姓名\": \"李四\", \"成绩\": 92},\n    {\"学号\": \"003\", \"姓名\": \"王五\", \"成绩\": 78}\n]\n\n# 写入 CSV\nwith open(\"output.csv\", \"w\", encoding=\"utf-8\", newline=\"\") as f:\n    writer = csv.DictWriter(f, fieldnames=[\"学号\", \"姓名\", \"成绩\"])\n    writer.writeheader()  # 写入标题行\n    writer.writerows(students)  # 写入所有数据\n```\n:::\n\n\n---\n\n## 文件路径处理\n\n### pathlib：现代路径处理\n\n```{mermaid}\nmindmap\n  root((pathlib))\n    路径操作\n      拼接路径\n      获取父目录\n      获取文件名\n    文件检查\n      exists 是否存在\n      is_file 是否是文件\n      is_dir 是否是目录\n    文件操作\n      read_text 读取\n      write_text 写入\n      mkdir 创建目录\n```\n\n::: {#0b15758d .cell execution_count=5}\n``` {.python .cell-code}\nfrom pathlib import Path\n\n# 创建路径对象\ndata_dir = Path(\"data\")\nfile_path = data_dir / \"grades.csv\"  # 用 / 拼接路径（跨平台！）\n\nprint(f\"路径: {file_path}\")\nprint(f\"文件名: {file_path.name}\")\nprint(f\"扩展名: {file_path.suffix}\")\nprint(f\"父目录: {file_path.parent}\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n路径: data/grades.csv\n文件名: grades.csv\n扩展名: .csv\n父目录: data\n```\n:::\n:::\n\n\n### 遍历目录\n\n::: {#f01ae137 .cell execution_count=6}\n``` {.python .cell-code}\nfrom pathlib import Path\n\n# 获取当前目录下所有文件\ncurrent_dir = Path(\".\")\nfor file in current_dir.iterdir():\n    if file.is_file():\n        print(f\"文件: {file.name}\")\n    elif file.is_dir():\n        print(f\"目录: {file.name}/\")\n\n# 递归查找所有 Python 文件\nfor py_file in current_dir.rglob(\"*.py\"):\n    print(py_file)\n\n# 按扩展名筛选\nfor csv_file in current_dir.glob(\"*.csv\"):\n    print(csv_file)\n```\n:::\n\n\n---\n\n## 让 AI 处理文件相关问题\n\n### 常见文件问题\n\n```{mermaid}\nflowchart TD\n    A[\"文件操作问题\"] --> B[\"路径问题\"]\n    A --> C[\"编码问题\"]\n    A --> D[\"权限问题\"]\n    \n    B --> B1[\"Windows vs Mac/Linux\"]\n    B --> B2[\"相对路径 vs 绝对路径\"]\n    B --> B3[\"文件不存在\"]\n    \n    C --> C1[\"UTF-8 vs GBK\"]\n    C --> C2[\"乱码处理\"]\n    \n    D --> D1[\"只读文件\"]\n    D --> D2[\"目录不存在\"]\n```\n\n### Prompt 示例：安全读取文件\n\n```\n写一个函数 read_file_safe(filepath)：\n- 读取文件内容\n- 自动处理 UTF-8 和 GBK 编码\n- 如果文件不存在，返回 None 而不是报错\n- 支持 Windows 和 Mac/Linux 路径\n```\n\n**AI 生成的代码**：\n\n::: {#2e53a210 .cell execution_count=7}\n``` {.python .cell-code}\nfrom pathlib import Path\n\ndef read_file_safe(filepath):\n    \"\"\"安全读取文件，自动处理编码\"\"\"\n    path = Path(filepath)\n    \n    # 检查文件是否存在\n    if not path.exists():\n        return None\n    \n    # 尝试不同编码\n    encodings = [\"utf-8\", \"gbk\", \"gb2312\", \"latin-1\"]\n    \n    for encoding in encodings:\n        try:\n            return path.read_text(encoding=encoding)\n        except UnicodeDecodeError:\n            continue\n    \n    return None  # 所有编码都失败\n\n# 测试\n# content = read_file_safe(\"data.txt\")\n# if content:\n#     print(content)\n# else:\n#     print(\"文件不存在或无法读取\")\n```\n:::\n\n\n---\n\n## 实战：批量处理文件\n\n### 场景：整理下载文件夹\n\n**需求**：\n1. 列出目录下所有文件\n2. 按扩展名分类（图片、文档、视频等）\n3. 移动到对应子目录\n4. 生成整理报告\n\n### 分步实现\n\n::: {#561a31ac .cell execution_count=8}\n``` {.python .cell-code}\nfrom pathlib import Path\n\ndef get_file_category(filename):\n    \"\"\"根据扩展名返回文件类别\"\"\"\n    ext = Path(filename).suffix.lower()\n    \n    categories = {\n        \"images\": [\".jpg\", \".jpeg\", \".png\", \".gif\", \".bmp\", \".webp\"],\n        \"documents\": [\".doc\", \".docx\", \".pdf\", \".txt\", \".xlsx\", \".pptx\"],\n        \"videos\": [\".mp4\", \".avi\", \".mkv\", \".mov\", \".wmv\"],\n        \"audio\": [\".mp3\", \".wav\", \".flac\", \".aac\"],\n        \"code\": [\".py\", \".js\", \".html\", \".css\", \".java\"],\n    }\n    \n    for category, extensions in categories.items():\n        if ext in extensions:\n            return category\n    \n    return \"others\"\n\n# 测试\nprint(get_file_category(\"photo.jpg\"))      # images\nprint(get_file_category(\"report.pdf\"))     # documents\nprint(get_file_category(\"movie.mp4\"))      # videos\nprint(get_file_category(\"random.xyz\"))     # others\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nimages\ndocuments\nvideos\nothers\n```\n:::\n:::\n\n\n### 完整整理脚本\n\n::: {#8c8da7d7 .cell execution_count=9}\n``` {.python .cell-code}\nfrom pathlib import Path\nimport shutil\n\ndef organize_files(source_dir, dry_run=True):\n    \"\"\"\n    整理文件到分类目录\n    \n    Args:\n        source_dir: 源目录\n        dry_run: 如果为 True，只显示将做什么，不实际执行\n    \n    Returns:\n        整理报告\n    \"\"\"\n    source = Path(source_dir)\n    report = {\"moved\": [], \"skipped\": [], \"errors\": []}\n    \n    if not source.exists():\n        return {\"error\": \"目录不存在\"}\n    \n    for file in source.iterdir():\n        if not file.is_file():\n            continue\n        \n        # 跳过隐藏文件\n        if file.name.startswith(\".\"):\n            report[\"skipped\"].append(str(file))\n            continue\n        \n        # 确定分类\n        category = get_file_category(file.name)\n        target_dir = source / category\n        target_path = target_dir / file.name\n        \n        if dry_run:\n            print(f\"将移动: {file.name} -> {category}/\")\n            report[\"moved\"].append({\"from\": str(file), \"to\": str(target_path)})\n        else:\n            try:\n                target_dir.mkdir(exist_ok=True)\n                shutil.move(str(file), str(target_path))\n                report[\"moved\"].append({\"from\": str(file), \"to\": str(target_path)})\n            except Exception as e:\n                report[\"errors\"].append({\"file\": str(file), \"error\": str(e)})\n    \n    return report\n\n# 先预览（dry_run=True）\n# report = organize_files(\"~/Downloads\", dry_run=True)\n# \n# 确认后执行\n# report = organize_files(\"~/Downloads\", dry_run=False)\n```\n:::\n\n\n::: {.callout-warning}\n## 先预览，再执行！\n操作文件时，先用 `dry_run=True` 预览将要做的操作，确认无误后再实际执行。\n:::\n\n---\n\n## 自动化思维\n\n### 什么任务适合自动化？\n\n```{mermaid}\nflowchart TD\n    A[\"日常任务\"] --> B{\"重复性高?\"}\n    B -->|是| C{\"规则明确?\"}\n    C -->|是| D{\"人工容易出错?\"}\n    D -->|是| E[\"✅ 适合自动化\"]\n    \n    B -->|否| F[\"❌ 不适合\"]\n    C -->|否| F\n    D -->|否| G[\"⚠️ 可选自动化\"]\n```\n\n### 适合自动化的场景\n\n| 场景 | 描述 | Python 工具 |\n|-----|------|------------|\n| 批量重命名 | 按规则重命名照片/文件 | `pathlib`, `shutil` |\n| 数据清洗 | 整理 Excel/CSV 中的数据 | `pandas` |\n| 日志分析 | 从日志中提取关键信息 | `re`, 字符串处理 |\n| 报表生成 | 定期生成数据报告 | `pandas`, `matplotlib` |\n| 文件备份 | 自动备份重要文件 | `shutil`, `zipfile` |\n\n---\n\n## 课后作业\n\n### 开始作业 3：文件批量处理工具\n\n**本周任务**：实现核心功能\n\n1. `list_dir(path)` - 列出目录内容\n2. `filter_by_ext(files, ext)` - 按扩展名筛选\n3. `batch_rename(files, pattern)` - 批量重命名\n\n**注意**：本周专注于 Core 测试，下周处理 Edge 情况\n\n---\n\n## 本章小结\n\n- **文件操作三步**：打开 → 读写 → 关闭，用 `with` 自动管理\n- **CSV 处理**：用 `csv.DictReader` 读取，`csv.DictWriter` 写入\n- **路径处理**：用 `pathlib.Path`，跨平台更安全\n- **编码问题**：始终指定 `encoding=\"utf-8\"`\n- **自动化思维**：重复 + 规则明确 + 容易出错 = 适合自动化\n- **安全第一**：操作文件前先预览（dry_run）\n\n下一章，我们将学习**错误处理**——让程序更加健壮。\n\n",
    "supporting": [
      "06-files_files"
    ],
    "filters": [],
    "includes": {}
  }
}